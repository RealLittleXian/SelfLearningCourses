/* 
 * CS:APP 数据实验室 
 * 
 * <请在此处填写您的姓名和用户ID>
 * 
 * bits.c - 包含您对实验室解决方案的源文件的文件。
 *          这是您将提交给助教的文件。
 *
 * 警告：不要包含 <stdio.h> 头文件；它会使 dlc 编译器混淆。尽管您可能会收到编译器警告，但您仍然可以在不包含 <stdio.h> 的情况下使用 printf 进行调试。总的来说，忽略编译器警告并不是一个好习惯，但在这个情况下是可以的。  
 */

#if 0
/*
 * 给学生的说明：
 *
 * 第一步：仔细阅读以下说明。
 */

您将通过编辑此源文件中的函数集合来提供对数据实验室的解决方案。

整数编码规则：
 
  用一个或多个 C 代码行替换每个函数中的 "return" 语句，以实现该函数。您的代码 
  必须符合以下风格：
 
  int Funct(arg1, arg2, ...) {
      /* 简要描述您的实现是如何工作的 */
      int var1 = Expr1;
      ...
      int varM = ExprM;

      varJ = ExprJ;
      ...
      varN = ExprN;
      return ExprR;
  }

  每个 "Expr" 只能使用以下内容：
  1. 整数常量 0 到 255（包括 0xFF），不允许使用大常量如 0xffffffff。
  2. 函数参数和局部变量（不允许使用全局变量）。
  3. 一元整数操作符 ! ~
  4. 二元整数操作符 & ^ | + << >>
    
  某些问题进一步限制了允许的操作符。每个 "Expr" 可以包含多个操作符。你不必限制每个操作符占一行。

  你明确禁止：
  1. 使用任何控制结构如 if, do, while, for, switch 等。
  2. 定义或使用任何宏。
  3. 在此文件中定义任何附加函数。
  4. 调用任何函数。
  5. 使用任何其他操作，如 &&, ||, -, 或 ?:。
  6. 使用任何形式的类型转换。
  7. 使用任何除了 int 之外的数据类型。这意味着你不能使用数组、结构体或联合。

 
  你可以假设你的机器：
  1. 使用 2 的补码，32 位整数表示。
  2. 进行算术右移。
  3. 当移位量小于 0 或大于 31 时，具有不确定的行为。

可接受的编码风格示例：
  /*
   * pow2plus1 - 返回 2^x + 1，其中 0 <= x <= 31
   */
  int pow2plus1(int x) {
     /* 利用位移计算 2 的幂 */
     return (1 << x) + 1;
  }

  /*
   * pow2plus4 - 返回 2^x + 4，其中 0 <= x <= 31
   */
  int pow2plus4(int x) {
     /* 利用位移计算 2 的幂 */
     int result = (1 << x);
     result += 4;
     return result;
  }

浮点数编码规则

对于要求你实现浮点运算的问题，编码规则不那么严格。你允许使用循环和条件控制。你允许使用 int 和 unsigned。你可以使用任意整数和 unsigned 常量。你可以在 int 或 unsigned 数据上使用任何算术、逻辑或比较操作。

你明确禁止：
  1. 定义或使用任何宏。
  2. 在此文件中定义任何附加函数。
  3. 调用任何函数。
  4. 使用任何形式的类型转换。
  5. 使用任何除了 int 或 unsigned 之外的数据类型。这意味着你不能使用数组、结构体或联合。
  6. 使用任何浮点数数据类型、操作或常量。

注意事项：
  1. 使用 dlc（数据实验室检查器）编译器（在手册中描述）来检查你的解决方案的合法性。
  2. 每个函数都有一个最大操作数（整数、逻辑或比较）的限制，你允许在函数实现中使用这些操作数。dlc 会检查最大操作数。
     注意，赋值（'='）不计入操作数；你可以使用任意数量的赋值而不受惩罚。
  3. 使用 btest 测试框架来检查你的函数的正确性。
  4. 使用 BDD 检查器正式验证你的函数。
  5. 每个函数的最大操作数在函数的头部注释中给出。如果手稿中的最大操作数与文件中的最大操作数不一致，请考虑此文件为权威来源。

/*
 * 第二步：根据编码规则修改以下函数。
 * 
 *   重要提示。避免评分惊喜：
 *   1. 使用 dlc 编译器检查你的解决方案是否符合编码规则。
 *   2. 使用 BDD 检查器正式验证你的解决方案是否产生正确答案。
 */


#endif